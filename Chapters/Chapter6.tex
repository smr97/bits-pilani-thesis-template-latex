% Chapter 1

\chapter{Graph based in-situ analytics} % Main chapter title

\label{Chapter6} % For referencing the chapter elsewhere, use \ref{Chapter1}

\lhead{Chapter 6. \emph{Graph based in-situ analytics}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
\section{The need for in-situ analytics}
Parallel simulations produce large amount of data. The traditional approach consists of writing this data to disk, reading it back from the disk and analyzing it. But this approach is extremely slow. An alternative would be to analyze the data online, as soon as it is provided by the simulation, before writing it to the disk. Thus the data is reduced in size before being written to the disk, which leads to a better performance.

%----------------------------------------------------------------------------------------
\section{The proposed algorithm}    %[TODO] where did this algorithm come from? why is this being done?
A variety of molecular (mechanical and biological) simulations, generate a large number of (from a few million to a few hundred million) points in a three dimensional space. The interactions between such molecules/points determines the position of the points generated in the next time-step of the solution. Hence the following (two dimensional) algorithm becomes a crucial step in the analytics on the data produced by these simulations:

\begin{enumerate}
\item Hash the set of points into squares in the 2D space using four different hash functions.
\item For each square in a given hash, make an undirected graph with an edge between two points \emph{iff} the euclidean distance between them is less than a given threshold {T}. This is an empirical parameter of the algorithm.
\item Fuse all graphs hence formed.
    \begin{itemize}
        \item For each point, unionize the four adjacency lists (formed in \texttt{Step 2}) corresponding to the four hash functions.
        \item Concatenate all such adjacency lists (one for each point) into a single graph.
    \end{itemize}
\item Output a set of connected components for this graph.
\end{enumerate}
The aforementioned hash functions tile the entire 2D space into several squares, each of side \begin{math}2\times{T}\end{math}. For a given point \begin{math} (x, y) \end{math}, a hash function hence outputs the co-ordinates of the square in which this point lies.

Hence, one such hash function would map \begin{math} (x, y) \end{math} to \begin{math} (\frac{x}{2\times{T}}, \frac{y}{2\times{T}}) \end{math}. The other three hash functions mentioned are obtained by shifting the origin of the 2D space to \begin{math}(0, \frac{T}{2}), (\frac{T}{2}, 0) \end{math}, and \begin{math}(\frac{T}{2}, \frac{T}{2})\end{math} respectively.

    The above design implies that for any two points that are at a distance of \begin{math} T \end{math} or less, they will be hashed into the same square in atleast one of the four hashes. Therefore there would be \begin{math} {4\times{O(4n{\frac{T}{R}}^2)}} \end{math} distance computations where \begin{math} R \end{math} is the range of the 2D space.
\section{Code}
\section{Profiling}
\section{Some optimizations}
